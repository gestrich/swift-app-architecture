--- docs/architecture/Principles.md	2026-02-15 09:18:21
+++ plugin/skills/swift-architecture/principles.md	2026-02-15 09:00:08
@@ -1,22 +1,24 @@
-# Core Principles
+# Architecture Principles
 
-This document outlines the core architectural principles that guide development.
+Core principles that guide the 4-layer Swift app architecture. Use these when making architectural decisions or reviewing code for compliance.
 
-## 1. Depth Over Width
+## The Five Principles
 
-App-layer code (CLI commands, `@Observable` models) calls **ONE** use case per user action. The use case orchestrates everything needed internally through multiple SDK and service calls. Avoid wide orchestration in app-layer code.
+### 1. Depth Over Width
 
-**Good (Depth):**
+App-layer code calls **ONE** use case per user action. The use case orchestrates everything internally.
+
+**Good (depth):**
 ```swift
-// CLI calls ONE use case
+// App layer calls ONE use case
 for try await progress in useCase.stream(options: opts) {
     print(progress)
 }
 ```
 
-**Bad (Width):**
+**Bad (width):**
 ```swift
-// CLI orchestrates multiple steps directly
+// App layer orchestrates multiple steps directly
 let worktree = try await gitClient.createWorktree(...)
 try await scriptRunner.runScript(...)
 try await gitClient.commit(...)
@@ -24,8 +26,10 @@
 try await apiClient.createPR(...)
 ```
 
-## 2. Zero Duplication
+**Why:** When a model orchestrates multiple steps directly, it becomes responsible for keeping all its state consistent after each step — refreshing dependent data, updating caches, handling partial failures. Miss one refresh and the UI shows stale data. Use cases solve this by making multi-step operations atomic from the model's perspective: each stream yield is a complete, consistent state that the model assigns directly. This also keeps the app-layer thin, makes business logic testable, and ensures CLI and Mac app don't duplicate orchestration.
 
+### 2. Zero Duplication
+
 CLI and Mac app share 100% of business logic through the Features layer. Use cases are consumed by both entry points — only the app-layer consumption differs.
 
 **Benefits:**
@@ -33,40 +37,51 @@
 - Add features once, both clients benefit
 - Single source of truth for business logic
 
-## 3. Use Cases Orchestrate
+**Pattern:**
+```
+Feature (use case) ← shared
+    ├── CLI command (Apps layer)
+    └── @Observable model (Apps layer)
+```
 
+### 3. Use Cases Orchestrate
+
 Features expose `UseCase` / `StreamingUseCase` conformers that orchestrate multi-step operations across SDKs and services. Use cases are the primary unit of business logic.
 
 ```swift
-// Feature layer: orchestrates multiple SDK calls
 public struct ImportDataUseCase: StreamingUseCase {
     private let apiClient: APIClient
     private let storageClient: StorageClient
 
     public func stream(options: ImportOptions) -> AsyncThrowingStream<Progress, Error> {
-        // Multi-step orchestration
+        // Multi-step orchestration across multiple SDKs
     }
 }
 ```
 
-## 4. SDKs Are Stateless
+**Rule:** If code coordinates multiple SDK/service calls, it belongs in a use case, not in an app-layer model or service.
 
+### 4. SDKs Are Stateless
+
 SDK clients are `Sendable` structs with no mutable state. Each method wraps a single operation (one CLI command, one API call). No business concepts, no app-specific types.
 
 ```swift
-// Stateless, reusable, no app-specific knowledge
 public struct GitClient: Sendable {
     public func checkout(branch: String) throws { }
     public func commit(message: String) throws { }
 }
 ```
 
-## 5. @Observable at the App Layer Only
+**Tests:**
+- Could another project use this SDK as-is? → Yes = correct
+- Does the SDK reference app-specific types? → Yes = violation
+- Does the SDK hold mutable state? → Yes = violation
 
-`@Observable` models exist only in the Apps layer where UI binding is needed. Models consume use case streams and update state for the UI. Use cases own the state data; models own the state transitions.
+### 5. @Observable at the App Layer Only
 
+`@Observable` models exist only in the Apps layer where UI binding is needed. Models consume use case streams and update state for the UI.
+
 ```swift
-// App layer: @Observable model consumes use case stream
 @MainActor @Observable
 class ImportModel {
     var state: ImportState = .idle
@@ -81,56 +96,37 @@
 }
 ```
 
+**State ownership:** Use cases own the data; models own the transitions.
+
 ## Why Layers?
 
-### 1. Zero Duplication
-- CLI and Mac app share 100% of business logic via Features
-- Fix once, works everywhere
-- Add features once, both clients benefit
+| Benefit | How |
+|---------|-----|
+| **Zero duplication** | CLI and Mac app share use cases |
+| **Easy testing** | Test use cases without UI; mock SDKs for unit tests |
+| **Clear responsibilities** | Every piece of code has an obvious home |
+| **Reusability** | SDKs work in any project; use cases back multiple entry points |
+| **Maintainability** | Changes isolated to appropriate layer; no circular dependencies |
 
-### 2. Easy Testing
-- Test use cases without UI
-- Mock SDKs for unit tests
-- Integration tests at the Feature layer
+## Feature-Based Structure
 
-### 3. Clear Responsibilities
-- Easy to find where code belongs
-- New functionality has an obvious home
-- Reduces mental overhead
+Each major capability corresponds to its own feature module containing use cases. App-layer entry points consume these features.
 
-### 4. Reusability
-- SDKs can be used by other projects
-- Use cases can back multiple app entry points
-- Core logic is UI-agnostic
-
-### 5. Maintainability
-- Changes are isolated to the appropriate layer
-- Dependencies flow downward only
-- No circular dependencies
-
-## Feature-Based Application Structure
-
-In a macOS application, each major capability should correspond to its own feature module containing use cases. App-layer entry points (Mac app, CLI) consume these features, promoting modularity and independent development.
-
-This mapping ensures:
+This ensures:
 - Each feature is independently buildable and testable
 - Features can be developed in isolation
-- Clear ownership and boundaries between different functionality
-- Features can be reused across multiple app entry points or extracted to separate projects
+- Clear ownership and boundaries
+- Features can be reused across entry points or extracted to separate projects
 
-## Summary
+## Compliance Checklist
 
-- **Apps** are thin entry points — CLI commands, `@Observable` models, server handlers
-- **Features** contain **use cases** that orchestrate multi-step workflows
-- **Services** hold **shared models**, configuration, and stateful utilities
-- **SDKs** are **stateless `Sendable` structs** — single operations, reusable
-- **Zero duplication** between CLI and Mac app — both share the same use cases
-- **Depth over width** — app layer calls one use case per action
-- **@Observable at the app layer only** — models consume streams, use cases own state data
+When reviewing code against these principles:
 
-## Further Reading
+- [ ] App-layer code calls one use case per user action (depth over width)
+- [ ] Business logic lives in Features, not duplicated between CLI and Mac app
+- [ ] Multi-step orchestration is in use cases, not app-layer models or services
+- [ ] SDKs are stateless `Sendable` structs with single-operation methods
+- [ ] `@Observable` only appears in the Apps layer
+- [ ] SDKs have no app-specific types or business concepts
+- [ ] Dependencies flow downward only (Apps → Features → Services → SDKs)
 
-- **[ARCHITECTURE.md](ARCHITECTURE.md)** — Architecture overview
-- **[Layers.md](Layers.md)** — Detailed layer descriptions with examples
-- **[Dependencies.md](Dependencies.md)** — Dependency rules and boundaries
-- **[Examples.md](Examples.md)** — Reference implementation walkthrough
