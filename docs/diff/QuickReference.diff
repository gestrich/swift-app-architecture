--- docs/architecture/QuickReference.md	2026-02-15 08:50:46
+++ plugin/skills/swift-architecture/SKILL.md	2026-02-15 11:36:13
@@ -1,231 +1,252 @@
-# Quick Reference Guide
+---
+name: swift-architecture
+description: Provides the 4-layer Swift app architecture (Apps, Features, Services, SDKs) including layer responsibilities, dependency rules, placement guidance, feature creation, configuration, code style, and reference examples. Use when the user asks about the architecture, needs to understand layers, wants to add code, create features, or review architectural compliance.
+user-invocable: true
+---
 
-Quick decision guides for common architectural questions.
+# Swift App Architecture
 
-## Where to Put Things
+A layered architecture for building Swift applications — macOS apps, CLI tools, and servers — emphasizing separation of concerns, code reuse across entry points, and testability through use case protocols.
 
-| What you're adding | Where it goes |
-|-------------------|---------------|
-| SwiftUI views | `apps/MyMacApp/Views/` |
-| `@Observable` models | `apps/MyMacApp/Models/` |
-| CLI commands | `apps/MyCLIApp/` |
-| Server handlers | `apps/MyServerApp/` |
-| Multi-step orchestration | `features/MyFeature/usecases/` |
-| Feature-specific types | `features/MyFeature/services/` |
-| Shared data models | `services/CoreService/Models/` |
-| Configuration / settings | `services/AuthService/`, `services/StorageService/` |
-| Stateful shared utility | `services/MyService/` |
-| Single API call wrapper | `sdks/APIClientSDK/` |
-| Single CLI command wrapper | `sdks/CLISDK/`, `sdks/GitSDK/` |
-| Use case protocol definitions | `sdks/Uniflow/` |
+## Which Document Do I Need?
 
-## Decision Flowcharts
+| Situation | Document |
+|-----------|----------|
+| Understanding the architecture overview | Start here |
+| Understanding why the architecture works this way | [principles.md](principles.md) |
+| Deciding which layer code belongs in | [layers.md](layers.md) |
+| Creating a new feature module | [creating-features.md](creating-features.md) |
+| Setting up configuration or data paths | [configuration.md](configuration.md) |
+| Writing or reviewing code style | [code-style.md](code-style.md) |
+| Seeing a full end-to-end implementation | [examples.md](examples.md) |
 
-### Where Does This Code Belong?
+## 4-Layer Overview
 
 ```
-Start: I need to add new code
-    ↓
-Is it UI, @Observable, or platform-specific I/O?
-    ├─ Yes → Apps Layer
-    │         (models, views, CLI commands, server handlers)
-    │
-    └─ No → Does it orchestrate multiple steps into a workflow?
-              ├─ Yes → Features Layer
-              │         (UseCase / StreamingUseCase)
-              │
-              └─ No → Is it a shared model, config, or stateful utility?
-                        ├─ Yes → Services Layer
-                        │
-                        └─ No → Is it a single operation (one API call, one command)?
-                                  ├─ Yes → SDKs Layer
-                                  │         (stateless Sendable struct)
-                                  └─ No → Services Layer (shared utility)
+┌─────────────────────────────────────────────────────────────┐
+│                         Apps Layer                           │
+│  ┌──────────────────┐  ┌──────────────────┐  ┌────────────┐ │
+│  │ MyMacApp         │  │ MyCLIApp         │  │ MyServer   │ │
+│  │ (@Observable     │  │ (ArgumentParser  │  │ App        │ │
+│  │  models + views) │  │  commands)       │  │            │ │
+│  └──────────────────┘  └──────────────────┘  └────────────┘ │
+│          Entry points, I/O, platform-specific concerns       │
+└────────────────────────┬────────────────────────────────────┘
+                         │ uses
+                         ▼
+┌─────────────────────────────────────────────────────────────┐
+│                       Features Layer                         │
+│  ┌──────────────────┐  ┌──────────────────┐  ┌────────────┐ │
+│  │ ImportFeature    │  │ ExportFeature    │  │ Sync       │ │
+│  │ (UseCases)       │  │ (UseCases)       │  │ Feature    │ │
+│  └──────────────────┘  └──────────────────┘  └────────────┘ │
+│   Multi-step orchestration via UseCase / StreamingUseCase    │
+└────────────────────────┬────────────────────────────────────┘
+                         │ uses
+                         ▼
+┌─────────────────────────────────────────────────────────────┐
+│                       Services Layer                         │
+│  ┌───────────────┐  ┌──────────────┐  ┌──────────────────┐ │
+│  │ CoreService   │  │ AuthService  │  │ StorageService   │ │
+│  │ • Models      │  │ • Config     │  │ • Persistence    │ │
+│  │ • Shared      │  │ • Tokens     │  │ • File paths     │ │
+│  │   types       │  │              │  │                  │ │
+│  └───────────────┘  └──────────────┘  └──────────────────┘ │
+│      Models, configuration, shared stateful utilities        │
+└────────────────────────┬────────────────────────────────────┘
+                         │ uses
+                         ▼
+┌─────────────────────────────────────────────────────────────┐
+│                        SDKs Layer                            │
+│  ┌───────────────┐  ┌──────────────┐  ┌──────────────────┐ │
+│  │ API Clients   │  │ CLI Wrappers │  │ Utility SDKs     │ │
+│  │ (REST, etc.)  │  │ (git, etc.)  │  │ (parsing, etc.)  │ │
+│  └───────────────┘  └──────────────┘  └──────────────────┘ │
+│     Stateless Sendable structs — reusable across projects    │
+└─────────────────────────────────────────────────────────────┘
 ```
 
-### Should This Be a Feature or Service?
+### Apps Layer (Entry Points)
 
-```
-I'm adding new business logic
-    ↓
-Does it orchestrate multiple steps into a workflow?
-    ├─ Yes → Feature Layer (use case)
-    │         (e.g., ImportUseCase, SyncUseCase)
-    │
-    └─ No → Is it a shared model, config, or utility?
-              ├─ Yes → Services Layer
-              │         (e.g., CoreService, AuthService)
-              │
-              └─ Not sure → Does it coordinate SDK calls?
-                            ├─ Yes → Feature Layer (use case)
-                            └─ No → Services Layer
-```
+Platform-specific entry points that handle I/O and own `@Observable` state.
 
-### Should This Be a Service or SDK?
+- Executable targets: macOS apps, CLI tools, server handlers
+- `@Observable` models live here — not in Services or Features
+- Minimal business logic; focus on I/O and calling features
+- Enum-based state in `@Observable` models (not multiple independent properties)
 
-```
-I'm adding functionality
-    ↓
-Is this ONE command or API call?
-    ├─ Yes → SDK Layer
-    │         (e.g., GitClient, APIClient)
-    │
-    └─ No → Is it a shared model or config used by multiple features?
-              ├─ Yes → Services Layer
-              │         (e.g., CoreService models, AuthService)
-              │
-              └─ Not sure → Could any project reuse this as-is?
-                            ├─ Yes → SDK Layer
-                            └─ No → Services Layer
-```
+### Features Layer (Use Cases)
 
-## Common Questions
+Multi-step orchestration via use case protocols.
 
-### Q: I'm adding a new feature to the app. Where does it go?
+- Use cases are structs conforming to `UseCase` or `StreamingUseCase` protocols
+- Coordinate multiple SDK clients and services into multi-step operations
+- Return `AsyncThrowingStream` for progress reporting
+- **Not** `@Observable` — that belongs in the Apps layer
 
-**A:** Create three things:
-1. **Feature module** in `features/MyFeature/` — use cases that orchestrate the logic
-2. **Mac app model** in `apps/MyMacApp/Models/` — `@Observable` model consuming use case streams
-3. **CLI command** in `apps/MyCLIApp/` — command consuming use cases directly (if CLI access needed)
+### Services Layer (Shared Models & Utilities)
 
-### Q: I need to add a git operation. SDK or Feature?
+Shared models, configuration, and stateful utilities used across features.
 
-**A:** Ask yourself:
-- **ONE git command?** → GitSDK (SDK)
-- **Multiple git commands in sequence?** → Feature use case
-- **Shared git config or models?** → Service
+- App-specific models and types
+- Configuration persistence (auth tokens, user settings)
+- Stateful utilities that don't orchestrate multi-step operations
 
-### Q: Where do `@Observable` models go?
+### SDKs Layer (Stateless, Reusable)
 
-**A:** Always in the **Apps layer** (`apps/MyMacApp/Models/`):
-- ✅ `apps/MyMacApp/Models/ImportModel.swift`
-- ❌ `features/ImportFeature/ImportModel.swift`
-- ❌ `services/CoreService/ImportModel.swift`
+Low-level, reusable building blocks with no app-specific logic.
 
-### Q: Where do I put data models?
+- Each method wraps a single operation (one CLI command, one API call)
+- **Stateless** — use `Sendable` structs, not actors or classes
+- Reusable across features and even across projects
 
-**A:** Depends on scope:
-- **Used by multiple features?** → `services/CoreService/Models/`
-- **Only used by one feature?** → `features/MyFeature/services/`
-- **Only used by the UI?** → `apps/MyMacApp/` (app layer)
+## Implementation Strategies
 
-### Q: Can a feature depend on another feature?
+The four layers are a logical structure. How they map to the build system varies:
 
-**A:** No — features depend on Services and SDKs only, not other features. If two features need shared logic:
-- Extract shared types to a **Service**
-- Extract shared operations to an **SDK**
-- If composition is needed, do it at the **App layer** (model composition or composite CLI commands)
+- **Targets in a single package** — Each module is a target in one `Package.swift`, grouped by layer folders. Good default for most projects.
+- **Separate Swift packages** — Each module has its own `Package.swift`. Common in large or multi-team codebases.
+- **Folders only** — Organizational folders within a single target. Suitable for small apps or prototypes.
 
-### Q: Can I call an SDK directly from an app?
+**Always match the convention already established in the codebase.** If starting fresh and unsure, ask which approach to use.
 
-**A:** For simple cases, yes:
-- ✅ Better: App → Feature (use case) → SDK
-- ⚠️ Acceptable: App → SDK (for trivial single-call operations)
-- ❌ Avoid: Complex SDK orchestration in apps (use a Feature instead)
+## Dependency Flow
 
-### Q: How do I share code between CLI and Mac app?
+Dependencies flow **downward only**:
 
-**A:** Put all shared logic in **Features** (use cases):
-- Both CLI commands and Mac models consume the same use cases
-- CLI calls `useCase.stream()` or `useCase.run()` directly
-- Mac models call use cases and update `@Observable` state
+```
+Apps → Features → Services → SDKs
+```
 
-### Q: Where does configuration go?
+- **Apps** depend on Features, Services, and SDKs
+- **Features** depend on Services and SDKs
+- **Services** depend on other Services and SDKs
+- **SDKs** depend only on other SDKs or external packages
+- Never depend upward
+- Features never depend on other features — compose at the App layer
 
-**A:** In the **Services layer**:
-- Auth tokens and credentials → `services/AuthService/`
-- File paths and storage → `services/StorageService/`
-- App-wide settings → `services/CoreService/`
-- See [Configuration.md](Configuration.md) for detailed patterns
+## Key Principles
 
-## Common Patterns
+1. **Depth Over Width** — App-layer code calls ONE use case per user action; orchestration lives in Features
+2. **Zero Duplication** — CLI and Mac app share the same use cases and features
+3. **Use Cases Orchestrate** — Features expose `UseCase` / `StreamingUseCase` conformers for multi-step operations
+4. **SDKs Are Stateless** — Single operations, `Sendable` structs, no business concepts
+5. **@Observable at the App Layer Only** — Models consume use case streams; use cases own state data, models own state transitions
 
-### Pattern: New Feature
+For the reasoning behind these principles, see [principles.md](principles.md).
 
-```
-1. Create use case module:
-   features/MyFeature/
-       ├── usecases/         UseCase / StreamingUseCase conformers
-       └── services/         Feature-specific types
+## Data Flow Patterns
 
-2. Add Mac app model:
-   apps/MyMacApp/Models/MyModel.swift     @Observable, consumes use case stream
-
-3. Add CLI command (optional):
-   apps/MyCLIApp/MyCommand.swift          Consumes use case directly
-
-4. Both app entry points depend on MyFeature
-5. Both consume the same use cases
+### CLI
 ```
-
-### Pattern: Multi-Step Workflow
-
+useCase.stream() → print progress
+useCase.run()    → print result
 ```
-1. Create StreamingUseCase in feature:
-   features/MyFeature/usecases/MyUseCase.swift
-   └── stream(options:) → AsyncThrowingStream<State, Error>
 
-2. Use case orchestrates SDKs and services:
-   apiClient.fetchData()      → SDK call
-   gitClient.commit()         → SDK call
-   coreService.saveConfig()   → Service call
-
-3. Mac app model consumes stream:
-   for try await state in useCase.stream(options: opts) {
-       self.state = ModelState(from: state)
-   }
-
-4. CLI command consumes stream:
-   for try await state in useCase.stream(options: opts) {
-       print(state)
-   }
+### Mac App
 ```
+useCase.stream() → @Observable model → View
+```
 
-### Pattern: Shared Types Across Features
+Both CLI commands and Mac models share the same use cases. The difference:
+- **Mac app** routes through `@Observable` models to update observable state
+- **CLI** uses use cases directly since there is no observable state
 
-```
-1. Define types in a service:
-   services/CoreService/Models/SharedModel.swift
+## Quick Reference: Where to Put Things
 
-2. Features import the service:
-   features/ImportFeature/ → depends on CoreService
-   features/ExportFeature/ → depends on CoreService
+| What you're adding | Where it goes | Layer |
+|-------------------|---------------|-------|
+| SwiftUI views | `apps/MyMacApp/Views/` | Apps |
+| `@Observable` models | `apps/MyMacApp/Models/` | Apps |
+| CLI commands | `apps/MyCLIApp/` | Apps |
+| Server handlers | `apps/MyServerApp/` | Apps |
+| Multi-step orchestration | `features/MyFeature/usecases/` | Features |
+| Feature-specific types | `features/MyFeature/services/` | Features |
+| Shared data models | `services/CoreService/Models/` | Services |
+| Configuration / settings | `services/AuthService/`, `services/StorageService/` | Services |
+| Stateful shared utility | `services/MyService/` | Services |
+| Single API call wrapper | `sdks/APIClientSDK/` | SDKs |
+| Single CLI command wrapper | `sdks/CLISDK/`, `sdks/GitSDK/` | SDKs |
+| Use case protocol definitions | `sdks/Uniflow/` | SDKs |
 
-3. Both features use SharedModel
-```
+For decision flowcharts and boundary guidance, see [layers.md](layers.md).
 
 ## Quick Checks
 
-### Before Creating a New Module
+**Before adding code:**
+- [ ] Am I putting this in the right layer?
+- [ ] Does this violate any dependency rules?
+- [ ] Is `@Observable` only in the Apps layer?
+- [ ] Is orchestration logic in Features (use cases), not in Apps or Services?
 
+**Before creating a new module:**
 - [ ] Is this really needed or can I extend an existing module?
-- [ ] What layer does this belong to? (App / Feature / Service / SDK)
-- [ ] What will depend on this?
+- [ ] What layer does this belong to?
 - [ ] Does it follow the `<Name><Layer>` naming convention?
 - [ ] Am I using the same implementation strategy (packages, targets, or folders) as the rest of the project?
 
-### Before Adding Code
 
-- [ ] Am I putting this in the right layer?
-- [ ] Does this violate any dependency rules?
-- [ ] Is there duplication I can eliminate?
-- [ ] Am I following the "depth over width" principle?
-- [ ] Is `@Observable` only in the Apps layer?
+## Performance Patterns
 
-### Before Committing
+### Parallel Processing
+- Use cases can process work concurrently using Swift Concurrency
+- Independent operations can run in parallel within a streaming use case
 
-- [ ] Can the module build independently? (when using targets or packages)
-- [ ] Are all dependencies flowing downward?
-- [ ] Is orchestration logic in Features (use cases), not in Apps or Services?
-- [ ] Are SDKs stateless `Sendable` structs?
+### Caching
+- Commit-based caching invalidates automatically when code changes
+- Per-module granularity minimizes redundant work
+- Three-level cache hierarchy: whole-repo snapshots, per-module caches, dependency graph caches
 
-## Getting Help
+### Lazy Loading
+- UI uses `LazyVStack` / `LazyHStack` for efficient scrolling
+- Data loaded on-demand
 
-See the detailed guides:
-- **[Layers.md](Layers.md)** — Layer descriptions and rules
-- **[Dependencies.md](Dependencies.md)** — Dependency rules and boundaries
-- **[FeatureStructure.md](FeatureStructure.md)** — How to structure features
-- **[Examples.md](Examples.md)** — Reference implementation
-- **[Principles.md](Principles.md)** — Core architectural principles
-- **[Configuration.md](Configuration.md)** — Configuration and data path management
-- **[swift-ui.md](swift-ui.md)** — SwiftUI and model architecture guidelines
+### Progress Reporting
+- Use cases report real-time progress via `AsyncThrowingStream`
+- Apps display progress however they choose (SwiftUI indicators, CLI terminal output, server logs)
+
+## Testing Strategy
+
+### Unit Tests
+- Test individual parsers and utilities
+- Test graph/dependency algorithms
+- Test cache invalidation logic
+
+### Integration Tests
+- End-to-end use case workflows
+- Cache hit/miss scenarios
+
+### Manual Testing via CLI
+- Use CLI commands against real data
+- Verify results match expectations
+
+## Common Questions
+
+**I'm adding a new feature to the app. Where does it go?**
+Create three things:
+1. **Feature module** in `features/MyFeature/` — use cases that orchestrate the logic
+2. **Mac app model** in `apps/MyMacApp/Models/` — `@Observable` model consuming use case streams
+3. **CLI command** in `apps/MyCLIApp/` — command consuming use cases directly (if CLI access needed)
+
+**Where do `@Observable` models go?**
+Always in the **Apps layer** (`apps/MyMacApp/Models/`). Never in Features or Services.
+
+**Can a feature depend on another feature?**
+No. If two features need shared logic, extract to a **Service** or **SDK**. Compose at the **App layer**.
+
+**How do I share code between CLI and Mac app?**
+Put all shared logic in **Features** (use cases). Both CLI commands and Mac models consume the same use cases.
+
+## Documentation Workflow
+
+Documentation follows this directory structure:
+
+```
+docs/
+├── proposed/        # In-progress specs and proposals
+└── completed/       # Finished implementation docs
+```
+
+- Create a proposal in `docs/proposed/` when planning new work
+- Move to `docs/completed/` once implementation is merged
+- `plugin/skills/` is the **single source of truth** for architecture documentation
