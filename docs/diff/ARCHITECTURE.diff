--- docs/architecture/ARCHITECTURE.md	2026-02-15 08:50:46
+++ plugin/skills/swift-architecture/SKILL.md	2026-02-15 11:36:13
@@ -1,11 +1,27 @@
+---
+name: swift-architecture
+description: Provides the 4-layer Swift app architecture (Apps, Features, Services, SDKs) including layer responsibilities, dependency rules, placement guidance, feature creation, configuration, code style, and reference examples. Use when the user asks about the architecture, needs to understand layers, wants to add code, create features, or review architectural compliance.
+user-invocable: true
+---
+
 # Swift App Architecture
 
-## Overview
+A layered architecture for building Swift applications — macOS apps, CLI tools, and servers — emphasizing separation of concerns, code reuse across entry points, and testability through use case protocols.
 
-This architecture guide describes a layered approach for building Swift applications — particularly macOS and iOS apps that may also expose CLI interfaces. The architecture emphasizes separation of concerns, code reuse across platform entry points, and testability through use case protocols.
+## Which Document Do I Need?
 
-## High-Level Architecture
+| Situation | Document |
+|-----------|----------|
+| Understanding the architecture overview | Start here |
+| Understanding why the architecture works this way | [principles.md](principles.md) |
+| Deciding which layer code belongs in | [layers.md](layers.md) |
+| Creating a new feature module | [creating-features.md](creating-features.md) |
+| Setting up configuration or data paths | [configuration.md](configuration.md) |
+| Writing or reviewing code style | [code-style.md](code-style.md) |
+| Seeing a full end-to-end implementation | [examples.md](examples.md) |
 
+## 4-Layer Overview
+
 ```
 ┌─────────────────────────────────────────────────────────────┐
 │                         Apps Layer                           │
@@ -50,71 +66,50 @@
 └─────────────────────────────────────────────────────────────┘
 ```
 
-## Implementation Strategies
+### Apps Layer (Entry Points)
 
-The four layers are a logical structure. How they map to the build system varies by project:
+Platform-specific entry points that handle I/O and own `@Observable` state.
 
-- **Targets in a single package** — Each module is a target in one `Package.swift`, grouped by layer folders (`features/`, `sdks/`, etc.). Good default for most projects.
-- **Separate Swift packages** — Each module is its own package with its own `Package.swift`. Common in large or multi-team codebases.
-- **Folders only** — Layer structure is organizational folders within a single target. Suitable for small apps or prototypes.
-
-Match the convention already established in the codebase. See [Layers.md — Implementation Strategies](Layers.md#implementation-strategies) for details.
-
-## Layer Breakdown
-
-### 1. Apps Layer (Entry Points)
-
-**Purpose**: Platform-specific entry points that handle I/O and own `@Observable` state.
-
-**Key Characteristics**:
 - Executable targets: macOS apps, CLI tools, server handlers
-- `@Observable` models live here (for SwiftUI apps) — not in Services or Features
-- CLI commands are app-layer constructs, parallel to Mac models
+- `@Observable` models live here — not in Services or Features
 - Minimal business logic; focus on I/O and calling features
-- Models consume use case streams and update state for the UI
-
-**State Management**:
 - Enum-based state in `@Observable` models (not multiple independent properties)
-- Models self-initialize on `init` — no need for views to trigger loading
-- Model composition: parent models hold child models as properties
-- See [swift-ui.md](swift-ui.md) for detailed model and view guidelines
 
-### 2. Features Layer (Use Cases)
+### Features Layer (Use Cases)
 
-**Purpose**: Multi-step orchestration via use case protocols.
+Multi-step orchestration via use case protocols.
 
-**Key Characteristics**:
 - Use cases are structs conforming to `UseCase` or `StreamingUseCase` protocols
 - Coordinate multiple SDK clients and services into multi-step operations
 - Return `AsyncThrowingStream` for progress reporting
-- App-specific business logic and orchestration lives here
 - **Not** `@Observable` — that belongs in the Apps layer
 
-**Use Case Protocols** (from a `Uniflow` SDK):
-- `UseCase`: Single `run(options:)` → returns one result
-- `StreamingUseCase`: Extends `UseCase` with `stream(options:)` → yields progress updates via `AsyncThrowingStream`
+### Services Layer (Shared Models & Utilities)
 
-### 3. Services Layer (Shared Models & Utilities)
+Shared models, configuration, and stateful utilities used across features.
 
-**Purpose**: Shared models, configuration, and stateful utilities used across features.
-
-**Key Characteristics**:
 - App-specific models and types
 - Configuration persistence (auth tokens, user settings)
 - Stateful utilities that don't orchestrate multi-step operations
-- Provide types and utilities consumed by features
 
-### 4. SDKs Layer (Stateless, Reusable)
+### SDKs Layer (Stateless, Reusable)
 
-**Purpose**: Low-level, reusable building blocks with no app-specific logic.
+Low-level, reusable building blocks with no app-specific logic.
 
-**Key Characteristics**:
 - Each method wraps a single operation (one CLI command, one API call)
-- **Stateless** — use `Sendable` structs for clients, not actors or classes
-- Operations return `AsyncThrowingStream` for progress or values for one-shot queries
+- **Stateless** — use `Sendable` structs, not actors or classes
 - Reusable across features and even across projects
-- Includes use case protocol definitions (`Uniflow`)
 
+## Implementation Strategies
+
+The four layers are a logical structure. How they map to the build system varies:
+
+- **Targets in a single package** — Each module is a target in one `Package.swift`, grouped by layer folders. Good default for most projects.
+- **Separate Swift packages** — Each module has its own `Package.swift`. Common in large or multi-team codebases.
+- **Folders only** — Organizational folders within a single target. Suitable for small apps or prototypes.
+
+**Always match the convention already established in the codebase.** If starting fresh and unsure, ask which approach to use.
+
 ## Dependency Flow
 
 Dependencies flow **downward only**:
@@ -128,18 +123,17 @@
 - **Services** depend on other Services and SDKs
 - **SDKs** depend only on other SDKs or external packages
 - Never depend upward
+- Features never depend on other features — compose at the App layer
 
-See [Dependencies.md](Dependencies.md) for detailed rules and boundaries.
-
 ## Key Principles
 
-1. **Use Cases Orchestrate** — Features expose `UseCase` / `StreamingUseCase` conformers that orchestrate multi-step operations across SDKs and services
-2. **Zero Duplication** — CLI and Mac app share the same use cases and features; only the app-layer consumption differs
-3. **SDKs Are Stateless** — Single operations, `Sendable` structs, no business concepts
-4. **Services Are Shared** — Models, configuration, and utilities used across features
+1. **Depth Over Width** — App-layer code calls ONE use case per user action; orchestration lives in Features
+2. **Zero Duplication** — CLI and Mac app share the same use cases and features
+3. **Use Cases Orchestrate** — Features expose `UseCase` / `StreamingUseCase` conformers for multi-step operations
+4. **SDKs Are Stateless** — Single operations, `Sendable` structs, no business concepts
 5. **@Observable at the App Layer Only** — Models consume use case streams; use cases own state data, models own state transitions
 
-See [Principles.md](Principles.md) for the full principles guide.
+For the reasoning behind these principles, see [principles.md](principles.md).
 
 ## Data Flow Patterns
 
@@ -154,10 +148,44 @@
 useCase.stream() → @Observable model → View
 ```
 
-Both CLI commands and Mac models share the same leaf use cases, ensuring consistent behavior. The difference is in orchestration:
-- **Mac app** routes through `@Observable` models so each model can update its observable state
-- **CLI** uses use cases directly since there is no observable state to track
+Both CLI commands and Mac models share the same use cases. The difference:
+- **Mac app** routes through `@Observable` models to update observable state
+- **CLI** uses use cases directly since there is no observable state
 
+## Quick Reference: Where to Put Things
+
+| What you're adding | Where it goes | Layer |
+|-------------------|---------------|-------|
+| SwiftUI views | `apps/MyMacApp/Views/` | Apps |
+| `@Observable` models | `apps/MyMacApp/Models/` | Apps |
+| CLI commands | `apps/MyCLIApp/` | Apps |
+| Server handlers | `apps/MyServerApp/` | Apps |
+| Multi-step orchestration | `features/MyFeature/usecases/` | Features |
+| Feature-specific types | `features/MyFeature/services/` | Features |
+| Shared data models | `services/CoreService/Models/` | Services |
+| Configuration / settings | `services/AuthService/`, `services/StorageService/` | Services |
+| Stateful shared utility | `services/MyService/` | Services |
+| Single API call wrapper | `sdks/APIClientSDK/` | SDKs |
+| Single CLI command wrapper | `sdks/CLISDK/`, `sdks/GitSDK/` | SDKs |
+| Use case protocol definitions | `sdks/Uniflow/` | SDKs |
+
+For decision flowcharts and boundary guidance, see [layers.md](layers.md).
+
+## Quick Checks
+
+**Before adding code:**
+- [ ] Am I putting this in the right layer?
+- [ ] Does this violate any dependency rules?
+- [ ] Is `@Observable` only in the Apps layer?
+- [ ] Is orchestration logic in Features (use cases), not in Apps or Services?
+
+**Before creating a new module:**
+- [ ] Is this really needed or can I extend an existing module?
+- [ ] What layer does this belong to?
+- [ ] Does it follow the `<Name><Layer>` naming convention?
+- [ ] Am I using the same implementation strategy (packages, targets, or folders) as the rest of the project?
+
+
 ## Performance Patterns
 
 ### Parallel Processing
@@ -192,15 +220,33 @@
 - Use CLI commands against real data
 - Verify results match expectations
 
-## Further Reading
+## Common Questions
 
-- **[Layers.md](Layers.md)** — Detailed layer descriptions with examples
-- **[Dependencies.md](Dependencies.md)** — Dependency rules and boundaries
-- **[FeatureStructure.md](FeatureStructure.md)** — How to structure feature modules
-- **[Examples.md](Examples.md)** — Reference implementation walkthrough
-- **[Principles.md](Principles.md)** — Core architectural principles
-- **[QuickReference.md](QuickReference.md)** — Decision flowcharts and common patterns
-- **[Configuration.md](Configuration.md)** — Configuration and data path management
-- **[swift-ui.md](swift-ui.md)** — SwiftUI and model architecture guidelines
-- **[code-style.md](code-style.md)** — Code style conventions
-- **[documentation.md](documentation.md)** — Documentation workflow and standards
+**I'm adding a new feature to the app. Where does it go?**
+Create three things:
+1. **Feature module** in `features/MyFeature/` — use cases that orchestrate the logic
+2. **Mac app model** in `apps/MyMacApp/Models/` — `@Observable` model consuming use case streams
+3. **CLI command** in `apps/MyCLIApp/` — command consuming use cases directly (if CLI access needed)
+
+**Where do `@Observable` models go?**
+Always in the **Apps layer** (`apps/MyMacApp/Models/`). Never in Features or Services.
+
+**Can a feature depend on another feature?**
+No. If two features need shared logic, extract to a **Service** or **SDK**. Compose at the **App layer**.
+
+**How do I share code between CLI and Mac app?**
+Put all shared logic in **Features** (use cases). Both CLI commands and Mac models consume the same use cases.
+
+## Documentation Workflow
+
+Documentation follows this directory structure:
+
+```
+docs/
+├── proposed/        # In-progress specs and proposals
+└── completed/       # Finished implementation docs
+```
+
+- Create a proposal in `docs/proposed/` when planning new work
+- Move to `docs/completed/` once implementation is merged
+- `plugin/skills/` is the **single source of truth** for architecture documentation
